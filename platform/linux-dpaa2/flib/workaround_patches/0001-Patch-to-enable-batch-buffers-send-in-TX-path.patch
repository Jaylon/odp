From deea36dc0dee527e761dbe7758ea7c9769ae05bb Mon Sep 17 00:00:00 2001
From: Malik Sandeep-B02416 <Sandeep.Malik@freescale.com>
Date: Wed, 14 Sep 2016 22:50:39 +0530
Subject: [PATCH] Patch to enable batch buffers send in TX path.

Signed-off-by: Malik Sandeep-B02416 <Sandeep.Malik@freescale.com>
---
 driver/qbman_portal.c              | 76 ++++++++++++++++++++++++++++++++++++++
 driver/qbman_sys.h                 | 10 +++++
 include/drivers/fsl_qbman_portal.h |  5 +++
 3 files changed, 91 insertions(+)

diff --git a/driver/qbman_portal.c b/driver/qbman_portal.c
index 7774398..6de7bd0 100644
--- a/driver/qbman_portal.c
+++ b/driver/qbman_portal.c
@@ -1265,3 +1265,79 @@ struct qbman_result *qbman_get_dqrr_from_idx(struct qbman_swp *s, uint8_t idx)
 	dq = qbman_cena_read(&s->sys, QBMAN_CENA_SWP_DQRR(idx));
 	return dq;
 }
+int qbman_swp_send_multiple(struct qbman_swp *s,
+                           const struct qbman_eq_desc *d,
+                           const struct qbman_fd *fd,
+                           int frames_to_send)
+{
+       uint32_t *p;
+       const uint32_t *cl = qb_cl(d);
+       uint32_t eqcr_ci;
+       uint8_t diff;
+       int sent = 0;
+       int i;
+       int initial_pi = s->eqcr.pi;
+       uint64_t start_pointer;
+
+       if (!s->eqcr.available) {
+               eqcr_ci = s->eqcr.ci;
+               s->eqcr.ci = qbman_cena_read_reg(&s->sys,
+                                QBMAN_CENA_SWP_EQCR_CI) & 0xF;
+               diff = qm_cyc_diff(QBMAN_EQCR_SIZE,
+                                  eqcr_ci, s->eqcr.ci);
+               if (!diff)
+                       goto done;
+               s->eqcr.available += diff;
+       }
+
+       /* we are trying to send frames_to_send  if we have enough space in the ring */
+       while (s->eqcr.available && frames_to_send--) {
+               p = qbman_cena_write_start_wo_shadow_fast(&s->sys,
+                                                         QBMAN_CENA_SWP_EQCR((initial_pi) & 7));
+               /* Write command (except of first byte) and FD */
+               memcpy(&p[1], &cl[1], 7 * 4);
+               memcpy(&p[8], &fd[sent], sizeof(struct qbman_fd));
+
+               initial_pi++;
+               initial_pi &= 0xF;
+               s->eqcr.available--;
+               sent++;
+       }
+
+done:
+       initial_pi =  s->eqcr.pi;
+       lwsync();
+
+       /* in order for flushes to complete faster */
+       /*For that we use a following trick: we record all lines in 32 bit word */
+
+       initial_pi =  s->eqcr.pi;
+       for (i = 0; i < sent; i++) {
+               p = qbman_cena_write_start_wo_shadow_fast(&s->sys,
+                                                         QBMAN_CENA_SWP_EQCR((initial_pi) & 7));
+
+               p[0] = cl[0] | s->eqcr.pi_vb;
+               initial_pi++;
+               initial_pi &= 0xF;
+
+               if (!(initial_pi & 7))
+                       s->eqcr.pi_vb ^= QB_VALID_BIT;
+       }
+
+       initial_pi = s->eqcr.pi;
+
+       /* We need  to flush all the lines but without load/store operations between them */
+  /* We assign start_pointer  before we start loop so that in loop we do not read it from memory */
+       start_pointer = (uint64_t)s->sys.addr_cena;
+       for (i = 0; i < sent; i++) {
+               p = (uint32_t *)(start_pointer + QBMAN_CENA_SWP_EQCR(initial_pi & 7));
+               dcbf((uint64_t)p);
+               initial_pi++;
+               initial_pi &= 0xF;
+       }
+
+       /* Update producer index for the next call */
+       s->eqcr.pi = initial_pi;
+
+       return sent;
+}
diff --git a/driver/qbman_sys.h b/driver/qbman_sys.h
index b775cc0..9f3c8a2 100644
--- a/driver/qbman_sys.h
+++ b/driver/qbman_sys.h
@@ -354,3 +354,13 @@ static inline void qbman_swp_sys_finish(struct qbman_swp_sys *s)
 {
 	free_page((unsigned long)s->cena);
 }
+static inline void *qbman_cena_write_start_wo_shadow_fast(struct qbman_swp_sys *s,
+                                                         uint32_t offset)
+{
+#ifdef QBMAN_CENA_TRACE
+       pr_info("qbman_cena_write_start(%p:%d:0x%03x)\n",
+               s->addr_cena, s->idx, offset);
+#endif
+       BUG_ON(offset & 63);
+       return (s->addr_cena + offset);
+}
diff --git a/include/drivers/fsl_qbman_portal.h b/include/drivers/fsl_qbman_portal.h
index 68eb8cd..6fc85b7 100644
--- a/include/drivers/fsl_qbman_portal.h
+++ b/include/drivers/fsl_qbman_portal.h
@@ -1103,4 +1103,9 @@ int qbman_swp_CDAN_disable(struct qbman_swp *s, uint16_t channelid);
  */
 int qbman_swp_CDAN_set_context_enable(struct qbman_swp *s, uint16_t channelid,
 				      uint64_t ctx);
+
+int qbman_swp_send_multiple(struct qbman_swp *s,
+                           const struct qbman_eq_desc *d,
+                           const struct qbman_fd *fd,
+                           int frames_to_send);
 #endif /* !_FSL_QBMAN_PORTAL_H */
-- 
1.9.1


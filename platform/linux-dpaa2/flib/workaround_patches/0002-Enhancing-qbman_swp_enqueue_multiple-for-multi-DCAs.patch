From eeebf62964a6463b8b4f97bc3608c96801ebe217 Mon Sep 17 00:00:00 2001
From: Sunil Kumar Kori <Sunil.Kori@nxp.com>
Date: Fri, 26 May 2017 12:29:25 +0530
Subject: [PATCH 2/2] Enhancing qbman_swp_enqueue_multiple for multi DCAs

Signed-off-by: Sunil Kumar Kori <Sunil.Kori@nxp.com>
ODP-988
---
 driver/qbman_portal.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/driver/qbman_portal.c b/driver/qbman_portal.c
index b18c59a..ad8b36b 100644
--- a/driver/qbman_portal.c
+++ b/driver/qbman_portal.c
@@ -540,12 +540,15 @@ int qbman_swp_enqueue_multiple(struct qbman_swp *s,
 		memcpy(&p[8], &fd[i], sizeof(*fd));
 		eqcr_pi++;
 		eqcr_pi &= 0xF;
+		/*Pointing to the next enqueue descriptor*/
+		cl += (sizeof(struct qbman_eq_desc) / sizeof(uint32_t));
 	}
 
 	lwsync();
 
 	/* Set the verb byte, have to substitute in the valid-bit */
 	eqcr_pi = s->eqcr.pi;
+	cl = qb_cl(d);
 	for (i = 0; i < num_enqueued; i++) {
 		p = qbman_cena_write_start_wo_shadow(&s->sys,
 				QBMAN_CENA_SWP_EQCR(eqcr_pi & 7));
@@ -554,6 +557,8 @@ int qbman_swp_enqueue_multiple(struct qbman_swp *s,
 		eqcr_pi &= 0xF;
 		if (!(eqcr_pi & 7))
 			s->eqcr.pi_vb ^= QB_VALID_BIT;
+		/*Pointing to the next enqueue descriptor*/
+		cl += (sizeof(struct qbman_eq_desc) / sizeof(uint32_t));
 	}
 
 	/* Flush all the cacheline without load/store in between */
-- 
1.9.1

